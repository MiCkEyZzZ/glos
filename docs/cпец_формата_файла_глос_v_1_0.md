# Спецификация формата файла GLOS v1.0

## Обзор

ГЛОС (регистратор/воспроизведение сигналов ГЛОНАСС) — бинарный формат для хранения GNSS IQ (In-phase/Quadrature)
сэмплов с полной метаданной информацией. Формат предназначен для:

- Эффективного потокового хранения высокоскоростных IQ данных (100+ Msps)
- Надежной целостности данных с контрольными суммами для каждого блока
- Обратной и прямой совместимости через версионирование
- Поддержки разных SDR-устройств и форматов IQ
- Опциональной компрессии для уменьшения объёма хранения

**Статус:** v1.0 - готов к производству
**Последнее обновление:** 2026
**Порядок байт:** Big-endian по умолчанию (см. раздел Endianness)

---

## Принципы проектирования

1. **Целостность данных**: CRC32 для заголовка и блоков данных
2. **Потоковая запись**: последовательная структура блоков, индекс не требуется
3. **Расширяемость**: поле версии и зарезервированное место для будущих улучшений
4. **Аппаратная независимость**: поддержка нескольких SDR типов и конфигураций
5. **Самоописываемость**: полные метаданные в заголовке (не требуется внешний конфиг)

---

## Структура файла

```
┌─────────────────────────────────────┐
│  GLOS File Header (128 bytes)       │
│  - Magic, version, metadata         │
│  - CRC32 checksum                   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│  IQ Block #1 (variable size)        │
│  - Timestamp, sample count          │
│  - IQ data (compressed or raw)      │
│  - CRC32 checksum                   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│  IQ Block #2                        │
└─────────────────────────────────────┘
         ↓
         ... (повторяется для каждого блока)
```

---

## Формат заголовка (128 байт, фиксированный)

```
 Смещение    Размер    Поле                           Тип         Примечания
──────────  ────────  ─────────────────────────────  ──────────  ────────────────────
0            4         Magic Number                   bytes[4]    Always "GLOS"
4            1         Version                        u8          Current: 1
5            1         Flags                          u8          Bit 0: endianness (0=BE, 1=LE)
6            6         Padding                        reserved    Must be 0x00
12           1         SDR Type                       enum        See SdrType table
13           1         IQ Format                      enum        See IqFormat table
14           1         Compression                    enum        See Compression table
15           1         Padding                        reserved    Must be 0x00
16           4         Sample Rate                    u32 BE      Hz (e.g., 2_000_000)
20           8         Center Frequency               u64 BE      Hz (e.g., 1_602_000_000)
28           4         Receiver Gain                  f32 BE      dB (e.g., 40.0)
32           8         Session Start Timestamp        u64 BE      Unix seconds
40           8         Session End Timestamp          u64 BE      Unix seconds (0=ongoing)
48           8         Total IQ Samples               u64 BE      All samples in file
56           16        Reserved (future use)          bytes       All 0x00 for v1.0
72           4         Header CRC32                   u32 BE      CRC of bytes [0..72)
76           52        Reserved                       bytes       All 0x00 for v1.0
128                    End of fixed header
```

> **Примечание о компоновке:** Поля `[0..72)` защищены CRC. CRC хранится по смещению `72`.
> Зарезервированное пространство `[76..128)` предназначено для будущих расширений заголовка
> без нарушения структуры CRC.

### Таблицы перечислений

**Тип SDR (1 байт)**

```
Значение  Устройство           Примечания
──────────────────────────────────────────
0         HackRF One           Популярное open-source
1         ADALM-PlutoSDR       Xilinx/Analog Devices
2         USRP B200 family     Ettus Research
255       Unknown/Generic      Резерв/неизвестно
```

**Формат IQ (1 байт)**

```
Значение  Формат      Размер сэмпла  Диапазон          Точность
────────────────────────────────────────────────────────────────────
0         Int8        2 байта        ±127              ~3 дБ на шаг
1         Int16       4 байта        ±32767            ~0.01 дБ на шаг
2         Float32     8 байт         ±1.0 (нормализ.)  IEEE 754 32-бит
```

**Компрессия (1 байт)**

```
Значение  Метод      Примечания
──────────────────────────────────────────────────
0         None       Сырые IQ данные
1         LZ4        Быстрое сжатие, ~2:1 типично
```

---

## Модель порядка байт (Endianness)

**По умолчанию:** Big-endian (сетевой порядок байт).

Если в `Flags` установлен бит 0:

- Все числовые поля в заголовке и блоках кодируются в little-endian.

**Исключение: поля CRC всегда хранятся в big-endian, независимо от выбранного режима endianness.**

Это обеспечивает независимость контрольных сумм от кодировки данных и упрощает кросс-платформенную верификацию.

```
Модель:  [ поля данных (BE или LE) ] [ CRC (всегда BE) ] [ reserved ]
```

---

## Формат блока IQ данных (переменный размер)

Каждый блок содержит последовательность IQ сэмплов с метаданными:

```
Offset  Size  Field                   Type               Notes
──────  ────  ──────────────────────  ─────────────────  ────────────────────────────────────────
0       4     Block Content Size      u32 (per flag)     Sample Count (4) + Timestamp (8) + IQ Data (N) = 12+N bytes
4       4     Sample Count            u32 (per flag)     Number of IQ pairs in block
8       8     Block Timestamp         u64 (per flag)     Unix nanoseconds (ns since epoch)
16      N     IQ Sample Data          bytes              N = Sample Count × IQ Format size
16+N    4     Block CRC32             u32 BE (always)    CRC of bytes [4..16+N)
```

> `(per flag)` — endianness определяется битом 0 поля `Flags` в заголовке файла.
> Поле `Block CRC32` всегда хранится в big-endian независимо от флага.

### Ограничения по размеру блока

- **Минимальный размер блока**: 20 байт (Block Content Size + Sample Count + Timestamp + CRC, при N=0)
- **Максимальный размер блока**: 1 MB (защита от DoS, эффективное буферизирование)
- **Рекомендуемый размер блока**: 256 KB – 1 MB для оптимальной потоковой работы

### Пример: 1000 сэмплов Int16

```
Размер содержимого блока: 4 + 8 + (1000 × 4) = 4012 байт
Общий размер блока:       4 + 4012 + 4 = 4020 байт
```

---

## Типы данных

### Кодирование IQ сэмплов

**Int8 формат** (I8, Q8)

```
Байт 0: I компонент (-128..127)
Байт 1: Q компонент (-128..127)
```

> Int8 однобайтовый — endianness не применяется.

**Int16 формат** (I16, Q16)

```
Байт 0-1: I компонент (-32768..32767), big-endian по умолчанию (little-endian если Flags bit 0 = 1)
Байт 2-3: Q компонент (-32768..32767), big-endian по умолчанию (little-endian если Flags bit 0 = 1)
```

**Float32 формат** (F32, F32)

```
Байт 0-3: I компонент (IEEE 754 single precision), big-endian по умолчанию (little-endian если Flags bit 0 = 1)
Байт 4-7: Q компонент (IEEE 754 single precision), big-endian по умолчанию (little-endian если Flags bit 0 = 1)
Диапазон: -1.0 to +1.0
```

> Endianness многобайтовых IQ-компонентов (Int16, Float32) определяется флагом файла.
> Int8 не затрагивается (однобайтовый формат).

---

## Проверка контрольных сумм

### Алгоритм CRC

Все CRC используют **CRC-32 (IEEE 802.3)**:

```
Polynomial (normal):  0x04C11DB7
Reflected polynomial: 0xEDB88320
Initial value:        0xFFFFFFFF
Final XOR:            0xFFFFFFFF
Input reflection:     yes
Output reflection:    yes
```

Эталонная реализация использует Rust-крейт [`crc32fast`](https://crates.io/crates/crc32fast).
Все остальные реализации должны точно соответствовать параметрам IEEE CRC-32.

> ⚠️ **Внимание:** Это **не** CRC-32C (Castagnoli, polynomial `0x1EDC6F41`).
> Использование неверного полинома приведёт к несовместимости с эталонной реализацией.

### Header CRC32

- **Диапазон:** байты `[0..72)`
- **Смещение хранения:** `72`
- **Кодирование:** big-endian (всегда, независимо от флага endianness)

```rust
crc32(header_bytes[0..72]) → u32 BE at offset 72
```

### Block CRC32

- **Диапазон:** байты `[4..16+N)`
- **Смещение хранения:** `16+N`
- **Кодирование:** big-endian (всегда)

```rust
crc32(block_bytes[4..16+N]) → u32 BE at offset 16+N
```

### Обработка ошибок

- **Несовпадение CRC заголовка:** Файл поврежден, отклонить весь файл.
- **Несовпадение CRC блока:** Пропустить этот блок, отметить как поврежденный в метаданных, продолжить.
- **Обрезанный блок в конце файла:** Корректно обработать частичный заключительный блок.

---

## Режимы валидации

**Streaming mode (потоковый режим)**

- `total_samples` может быть равно нулю (запись ещё не завершена)
- `timestamp_end` может быть равно нулю (сессия ongoing)

**Strict mode (строгий режим, после завершения записи)**

- Если `timestamp_end != 0`, значение `total_samples` должно совпадать с суммой сэмплов по всем блокам.
- Используется для архивирования и верификации завершённых файлов.

---

## Стратегия обратной совместимости

### Версионирование и точка заморозки формата

**До v1.0:**

- Бинарная совместимость не гарантируется.
- Компоновка заголовка может измениться.

**Начиная с v1.0:**

- Компоновка заголовка фиксируется и становится стабильной.
- Любое ломающее бинарное изменение требует инкремента версии формата.
- На уровне reader должна соблюдаться обратная совместимость.

### Нумерация версий

- **Основные изменения версии** (v1 → v2): Изменение формата, старые reader не смогут корректно читать файл.
- **Незначительное изменение версии** (в будущем): Неразрушающие дополнения в пределах зарезервированного пространства.

### Путь миграции v1 → v2

1. Все reader должны проверять поле версии по смещению `4`.
2. Если `version > SUPPORTED_VERSION` — прервать с понятным сообщением об ошибке.
3. Если `version < SUPPORTED_VERSION` — попытаться использовать устаревший парсер, если доступен.
4. Новые поля размещать в зарезервированном пространстве (смещение `76–128`).

### Использование зарезервированного пространства

Текущий формат резервирует 52 байта (смещение `76–128`) для будущего использования:

- Улучшенные форматы временных меток (точность до наносекунд уже включена в блоки)
- Метаданные шифрования
- Параметры уровня сжатия
- Данные калибровки (фазовый/амплитудный дисбаланс I/Q)

> Readers должны **игнорировать** ненулевые значения в зарезервированных байтах — это обеспечивает прямую совместимость при расширении формата.

---

## Эталонная реализация

Каноническая эталонная реализация формата GLOS предоставляется в виде Rust-крейта `glos-core`.

Всё нормативное поведение (вычисление CRC, обработка endianness, валидация блоков, правила восстановления после ошибок) определяется этой реализацией.

**При расхождении между данным документом и эталонным кодом — эталонная реализация имеет приоритет до момента обновления спецификации.**

### Rust (библиотека glos-core)

**Основные типы:**

- `GlosHeader`: Сериализуемый заголовок с проверкой
- `IqBlock`: Блок данных переменного размера с проверкой целостности
- `SdrType`, `IqFormat`, `Compression`: Перечисления с преобразованием байтов

**Основные функции:**

- `header.serialize()` → `[u8; 128]`
- `GlosHeader::deserialize(buf)` → `GlosResult<Header>`
- `block.serialize()` → `Vec<u8>`
- `IqBlock::deserialize(buf)` → `GlosResult<(Block, bytes_read)>`
- `crc32_checksum(data)` → `u32`

**Зависимости:**

- `crc32fast`: Вычисление CRC32 (IEEE 802.3)
- `std::io`: Файловый I/O

### Привязка C/C++ (в будущем)

```c
typedef struct {
    uint32_t magic;
    uint8_t  version;
    uint8_t  flags;
    // ... другие поля
    uint32_t crc32_header; /* offset 72, always big-endian */
} GlosHeader;

int glos_header_parse(const uint8_t *buf, GlosHeader *out);
int glos_header_write(uint8_t *buf, const GlosHeader *hdr);
```

### Привязка Python (в будущем)

```python
import glos_core

with glos_core.GlosFile("recording.glos") as f:
    print(f.header.sdr_type)
    print(f.header.total_samples)

    for block in f.read_blocks():
        print(f"Block: {block.sample_count} samples")
        process(block.data)
```

---

## Пример: Запись файла

```rust
// Создание заголовка
let mut header = GlosHeader::new(
    SdrType::HackRf,
    2_000_000,           // 2 Мспс
    1_602_000_000,       // 1602 МГц (ГЛОНАСС L1)
);

header.gain_db = 40.0;
header.iq_format = IqFormat::Int16;

// Сериализация заголовка
let header_bytes = header.serialize()?;
file.write_all(&header_bytes)?;

// Блоки записи
for chunk in iq_data.chunks(10_000) {
    let block = IqBlock::new(
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64,
        chunk.len() as u32,
        chunk.to_vec(),
    );
    let block_bytes = block.serialize()?;
    file.write_all(&block_bytes)?;
}

// Обновление заголовка с итоговой статистикой
header.timestamp_end = /* текущее время */;
header.total_samples = /* накопленный */;

file.seek(SeekFrom::Start(0))?;
file.write_all(&header.serialize()?)?;
```

---

## Пример: Чтение файла

```rust
// Чтение и проверка заголовка
let mut header_buf = [0u8; GLOS_HEADER_SIZE];
file.read_exact(&mut header_buf)?;
let header = GlosHeader::deserialize(&header_buf)?;

println!("SDR: {:?}, Sample Rate: {} Hz", header.sdr_type, header.sample_rate);
println!("Total samples: {}", header.total_samples);

// Последовательное чтение блоков
let mut stream = BufReader::new(file);
let mut buffer = vec![0u8; 1024 * 1024]; // Буфер чтения 1 МБ
let mut total_read = 0;

loop {
    let n = stream.read(&mut buffer)?;
    if n == 0 { break; }

    let mut offset = 0;
    while offset < n {
        match IqBlock::deserialize(&buffer[offset..n]) {
            Ok((block, bytes_read)) => {
                println!("Block: {} samples, timestamp: {}",
                    block.sample_count, block.timestamp_ns);
                process_iq_samples(&block.data);
                offset += bytes_read;
                total_read += bytes_read;
            }
            Err(e) => {
                eprintln!("Block decode error: {}, skipping byte", e);
                // Восстановление: сдвиг на 1 байт в поисках следующего валидного блока
                offset += 1;
            }
        }
    }
}

println!("Total bytes processed: {}", total_read);
```

> **Внутренняя заметка (производительность):** Восстановление после ошибок использует `Vec::drain()`
> на остаточном буфере. При высокой плотности повреждений это может привести к поведению O(n²).
> Кандидаты для будущей оптимизации: ring buffer, sliding window с cursor offset, `VecDeque`.
> В нормальном файле плотность повреждений ≈ 0%, поэтому текущая реализация является предпочтительной.

---

## Тестовые векторы

### Тестовый вектор #1: Минимальный допустимый файл

**Заголовок:**

- Magic: `"GLOS"`
- Version: `1`
- SDR Type: HackRF (`0`)
- IQ Format: Int16 (`1`)
- Compression: None (`0`)
- Sample Rate: 2,000,000 Hz
- Center Freq: 1,602,000,000 Hz
- Gain: 40.0 dB
- Start Time: `1704067200` (2024-01-01 00:00:00 UTC)
- End Time: `1704067260` (60 секунд позже)
- Total Samples: 120,000,000
- Header CRC32: вычисляется по байтам `[0..72)`

**Блоки:**

- Блок 1: `timestamp=1704067200_000000000 ns`, 10,000 Int16 samples (40 KB)
- Блок 2: `timestamp=1704067200_005000000 ns`, 10,000 Int16 samples (40 KB)
- ... (итого 12,000 блоков)

**Общий размер файла:** 128 + (12,000 × 4024) ≈ 48.3 MB

### Тестовый вектор #2: Сжатый файл

То же, что и тестовый вектор №1, но:

- Сжатие: LZ4 (`1`)
- Содержимое каждого блока (данные IQ) сжато до размера примерно 50%
- Ожидаемый общий размер файла: ~24 МБ

### Тестовый вектор #3: Обнаружение поврежденных блоков

Файл с умышленным повреждением:

- Valid header
- Block 1: Valid
- Block 2: CRC corrupted (single bit flip in data)
- Block 3: Valid

**Ожидаемое поведение:**

- Header validates ✓
- Block 1 processes ✓
- Block 2 fails CRC check, logged as corrupted ✓
- Block 3 processes ✓
- Total recoverable samples: 20,000 (blocks 1+3)

---

## Характеристики производительности

### Streaming Write Performance

| Частота дискретизации | Формат IQ | Размер блока | Скорость записи | Использование ЦП |
| --------------------- | --------- | ------------ | --------------- | ---------------- |
| 2 Msps                | Int16     | 256 Кб       | 8 Мб/с          | ~10% (1 ядро)    |
| 50 Msps               | Int16     | 1 Мб         | 200 Мб/с        | ~25% (1 ядро)    |
| 100 Msps              | Int16     | 1 Мб         | 400 Мб/с        | ~40% (1 ядро)    |

_Примечание: Предполагается буферизованный ввод-вывод, типичная скорость записи на SSD составляет ~500 МБ/с._

### Производительность чтения/воспроизведения

| Размер файла | Сжатие | Время анализа | Использование ЦП    |
| ------------ | ------ | ------------- | ------------------- |
| 50 Мб        | Нет    | 0.5 сек       | ~5%                 |
| 50 Мб        | LZ4    | 2.0 сек       | ~60% (декомпрессия) |
| 1 Гб         | Нет    | 10 сек        | ~5%                 |

---

## Вопросы безопасности

### Защита целостности

- CRC32 обнаруживает случайные изменения битов (99,99% ошибок).
- _Будущее улучшение (v2):_ HMAC-SHA256 для обнаружения попыток взлома
- _Будущее улучшение (v2):_ Шифрование AES-256 для обеспечения конфиденциальности

### Предотвращение атак типа DoS

- Максимальный размер блока: 1 МБ (предотвращает исчерпание памяти)
- Проверка версии (немедленно отклоняет неизвестные версии)
- Проверка CRC прерывается при повреждении заголовка

### Рекомендации по применению в производстве

1. **Аутентификация:** Подпишите файл цифровой подписью (вне формата `.glos`)
2. **Шифрование:** Шифрование файла в состоянии покоя с использованием механизмов на уровне ОС (например, LUKS, FileVault)
3. **Проверка:** Периодически проверяйте контрольные суммы CRC сохранённых файлов
4. **Ведение журнала аудита:** Регистрируйте все обращения к файлам и их изменения

---

## Список изменений

### v1.0 (2026) — Первый релиз

- ✅ Fixed 128-byte header format
- ✅ Header CRC32 over bytes `[0..72)`, stored at offset `72`
- ✅ CRC algorithm: IEEE 802.3 CRC-32 (polynomial `0xEDB88320`)
- ✅ CRC fields always big-endian regardless of endianness flag
- ✅ Endianness flag support (Flags bit 0)
- ✅ Variable-size IQ data blocks
- ✅ CRC32 integrity protection
- ✅ Support for Int8/Int16/Float32 formats
- ✅ SDR device type enumeration
- ✅ Optional compression field (None / LZ4)
- ✅ Streaming and strict validation modes
- ✅ Version and flag fields for extensibility
- ✅ Complete test vectors
- ✅ Rust reference implementation

---

## ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ

**В: Почему используется порядок байтов big-endian, а не little-endian?**
О: Порядок байтов big-endian не зависит от платформы и является стандартом для бинарных протоколов. Little-endian можно включить через бит 0 поля `Flags`.

**В: Почему CRC всегда хранится в big-endian?**
О: CRC — это маркер целостности "wire format". Он должен быть независим от endianness данных, чтобы упростить кросс-платформенный инструментарий и верификацию.

**В: Почему CRC считается по `[0..72)`, а не по всему заголовку?**
О: Поля после CRC — зарезервированное пространство для будущих расширений. Такая компоновка `[ поля ][ CRC ][ reserved ]` позволяет добавлять новые поля без изменения структуры CRC.

**В: Можно ли добавлять блоки к существующему файлу?**
О: Да. Переместитесь в конец файла и запишите новые блоки. Не забудьте обновить поля заголовка (`timestamp_end`, `total_samples`), переместившись на смещение `0`.

**В: Что произойдет, если во время записи отключится питание?**
О: Проверка CRC обнаружит усечённый последний блок и пропустит его. Все полные блоки остаются восстанавливаемыми.

**В: Как сжать существующие файлы `.glos`?**
О: Используйте инструмент `glos-compact`: считывает файл v1 в несжатом виде, записывает файл v1 с `Compression = LZ4`.

**В: Существует ли максимальный размер файла?**
О: Жёсткого ограничения нет. Поле `total_samples` — `u64` (максимум ~18 эксабайт при 1 сэмпле/байт). Практическое ограничение определяется файловой системой (ext4: 16 ТБ, NTFS: 16 ЭБ).

**В: Можно ли смешивать типы SDR в одном файле?**
О: Нет. Поле `SDR Type` фиксировано для каждого файла. Создавайте отдельные файлы для разных устройств.

**В: Насколько точна метка времени?**
О: В заголовке используются секунды Unix (точность 1 секунда). В метках времени блоков используются наносекунды (разрешение 1 нс; фактическая точность зависит от источника времени).

---

## Ссылки

- Реализация CRC-32: [crate crc32fast](https://crates.io/crates/crc32fast)
- Алгоритм CRC-32 (IEEE 802.3): [Wikipedia — CRC-32](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)
- Формат IEEE 754 Float: [Wikipedia — IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)
- Обработка сигналов GNSS: Каплан, Э. Д., и Хегарти, К. (ред.). (2017). _Understanding GPS/GNSS_
- Спецификация ГЛОНАСС: [Федеральное космическое агентство Российской Федерации](https://www.roscosmos.ru/)

---

## Метаданные документа

- **Format Version:** 1.0
- **Specification Status:** Final (Production Ready)
- **Last Updated:** 2026
- **Maintainer:** GLOS Project Team
- **License:** Apache 2.0
